% Lokální makra patří do hlavního souboru, ne sem.
% Tady je mám výjimečně proto, že chci nechat hlavní soubor bez maker,
% která jsou jen pro tento dokument. Uživatelé si pravděpodobně budou
% hlavní soubor kopírovat do svého dokumentu.

\def\ctustyle{{\ssr CTUstyle}}
\def\ttb{\tt\char`\\} % pro tisk kontrolních sekvencí v tabulkách


\chap Device design and architecture


\sec Requirements discussion

The system is designed to fulfill both Safety Integrity Level (SIL) and non-SIL functions. For simplicity in development and discussion, the device can be divided into two main components: the SIL component and the non-SIL component.

The SIL component is responsible for monitoring the functionality of the LED modules, communicating their status to the Simatic PLC, and sharing this data with the non-SIL software. In the context of the device’s overall operation (see TOODODDDDDDD Illustration 2.7), the SIL component reads data from the LED modules, processes it, stores it in a location accessible to the non-SIL component, and transmits it to the Simatic PLC. The PLC then uses this feedback to determine whether the requested action has been executed correctly.

The non-SIL component ensures reliable retrieval of status data from the SIL component regarding the LED modules. It handles the booting and initialization of the SIL component and hosts a REST API server to enable data monitoring and software updates. Additionally, it supports supplementary non-SIL monitoring functions.

To better understand, let’s divide the software into four basic components:

\begitems
* Booting
* Standard operation
* Software update
* Safety shutdown
\enditems

\sec Booting

First, let’s describe the boot process. The AM243x is a multi-core processor that utilizes a multistage booting sequence. By TI naming convention, the booting sequence is divided into {\it ROM boot} and {\it SBL boot}.

\secc ROM boot

The {\sbf ROM boot} (also RBL) is stored in read-only memory and is almost considered as part of the SoC. As soon as the board is powered ON, the ROM bootloader or RBL starts running. The RBL is the primary bootloader.
Depending on which boot mode is selected, the RBL will load the secondary bootloader or SBL from a boot media. It is via UART in our case. The rest of the booting is done by the SBL.~\cite[sde5XPrz4Ejc1Hax]

The {\sbf ROM code} is code that is executed in this phase.

The ROM can operate in the three modes by the device type:

\begitems
* {\sbf HS-Field Securable device} (HS-FS) - This is the HS device state before the customer keys are provisioned in the device (the state at which the HS device leaves the TI factory); secure features are not available and the device protects the ROM code, TI keys, and certain security peripherals; the device does not force auth for booting.
* {\sbf HS-Field Enforced device} (HS-SE) - This is the HS device state after the customer keys are successfully provisioned in the device; all security features are enabled, all secrets within the device are fully protected, all of the security goals are fully enforced, the debug override sequence is supported, and the device forces security booting.
* {\sbf General-purpose device} (GP) - This is the non-secure device state intended for general-purpose applications; no security features are enforced, secure booting is not required, and the device allows open access to all peripherals and debug features without authentication.
\enditems

Final system is targeting the HS-SE device type. The thesis prototype device is targeting the GP device type only.

In a general-purpose device, DMSC ROM (Device Management System Controller ROM) performs the following functions:

\begitems
* Device management
* Configures the boot vectors and controls reset release of R5 core. That is, DMSC is the boot controller of the R5 core.
* IPC configuration via Main DMSS rings and Secure Proxy
* PLL configuration (R5 and SA2UL)
* X509 certificate parsing
* SA2UL configuration to SHA512 for image integrity checks
* DMSC firmware loading~\cite[fcLWZx8KgBoQyWDm]
\enditems

\secc SBL boot

The {\sbf SBL boot} (Secondary Bootloader) typically does a bunch of SoC-specific initializations and proceeds to the application loading. Depending on the type of SBL loaded, the SBL looks for the multicore app image of the application binary at a specified location in a boot media.

\secc Boot modes

Device allows several boot modes divided into two classes:
\begitems
* {\sbf host} boot modes (Ethernet, UART, USB, ...)
* and {\sbf memory} boot modes (MMCSD,\fnote{eMMC Flash or SD card} GPMC,\fnote{NOR flash, NAND flash} QSPI, ...).
\enditems

Device provides {\sbf Primary Boot Mode} and {\sbf Secondary (Backup) Boot Mode}, that is started when Primary Boot Mode fails (it is illustrated in the Figure \ref[SWFlowBoot]). The mode is set up by BOOTMODE pins.~\fnote{Detail description can be found in the {\it AM243x Technical Reference Manual} in the chap 4.3.1 \cite[fcLWZx8KgBoQyWDm].} On the Devkit, a hardware mutex is placed to control BOOT pins (illustrated in the Figure \ref[BootPinMutexPhoto]).


\medskip
\clabel[BootPinMutexPhoto]{Boot Pin Mutex}
\picw=14cm \cinspic img/05-boot-pin-mutex.jpg
\caption/f The Boot Pin Mutex on the Devkit board LP-AM243x.
\medskip

\secc Device boot phases

In my device, I divide the boot process into two phases. These phases are not the same as RBL and SBL. It is a different division. RBL and SBL are, to some extent, part of both phases.

The {\sbf first phase}, which I call the {\sbf bootloader}, is responsible for loading software from flash memory into individual CPUs, verifying the validity of certificates, performing basic initialization, and managing software versions.

During the {\sbf second phase}, the device is already running standard operations on each core of the device.

In addition to these two phases, I include a third phase called {\sbf flash writer}. This phase is tasked with downloading software during the initial loading into the device and is only executed when the device does not boot from the primary flash memory source but from a secondary (backup) Ethernet source. This part of the code is provided to the device before the actual loading from a server that uploads the software and is never stored in the device's flash memory.

Overall, the software comprises the following parts:

\begitems
* {\sbf Flash writer}: a component that ensures the loading of software into flash memory.  
* {\sbf Bootloader}: a component that is launched first after a successful system startup and manages other software parts, such as loading and validation.  
* {\sbf Images for each core}: a component that contains running standard operations.
\enditems

\medskip
\clabel[SWFlowBootOverview]{Software Flow Boot overview}
\picw=10cm \cinspic img/05-sw-flow-overview.png
\caption/f Overview of the boot process, illustrating the relationships and transitions between the bootloader, flash writer, and core operation phases.
\medskip

Due to the multi-core architecture, it is necessary to use the DMSC (Device Management System Controller) in the device, which is managed by firmware referred to by TI as SYSFW (System Firmware). This layer functions as a {\it black box} and provides an API for Resource Management, Power Management, and Security. The DMSC is uploaded in the device as a part of the SDK with device images.

\secc Boot image format

Each block consists of a certificate and the software itself and is loaded into flash memory at a specific address (illustrated in the Figure \ref[BootImageFormat]). The device uses X.509 certificates described in the norm RFC 5280~\fnote{\url{https://datatracker.ietf.org/doc/html/rfc5280}}.

\medskip
\clabel[BootImageFormat]{Boot Image Format}
\picw=10cm \cinspic img/05-sw-boot-image-format.png
\caption/f The Boot Image format.
\medskip

In general, an X.509 certificate contains a public key which has been signed by a private key. The public ROM code does not directly use the keys. In non-secure devices (GP), the public key value is in general a don't care condition. The exception is certificates containing a degenerate RSA public key. GP devices with a degenerate RSA key allow for integrity checking of most (but not all) of the certificate. As I mentioned below, we are using the device in the GP mode. It means that our device integrity in the prototype is validated by the degenerate RSA public key.~\cite[fcLWZx8KgBoQyWDm]

The ROM code is getting two additional pieces of information from the X.509 certificate:

\begitems
* The total size of the X.509 certificate
* The total size of the boot image
\enditems

The ROM defines several extensions that are used only by TI for boot. These are placed in the extensions field of the TBS\fnote{to be signed} certificate.

\secc Detailed System Initialization Description

During the DMSC initialization phase, as depicted in Figure \ref[SWFlowBootDeviceDMSCInit], the R5 core reads the boot mode pins to configure the appropriate peripheral interface, enabling access to the boot image. The R5 performs a preliminary validation of the image before transferring it to the DMSC. The DMSC ROM then verifies the code and loads the validated boot image into on-chip RAM. If the image verification fails but the boot mode pins indicate a secondary (backup) boot mode, the DMSC ROM loads the backup image into on-chip RAM. This functionality is utilized by our system to initially boot software using the flash writer component. After receiving the image, the R5 enters a clean state and idles. The DMSC ROM asserts a reset on the MCU, redirects the boot vector to the newly loaded image, and releases the reset. This process restarts the R5 with the Public ROM code fully disconnected, as illustrated in Figure \ref[SWFlowBootSystemInitialization].

The boot sequence then proceeds based on the boot mode: for the primary mode, the system boots from flash memory and executes the bootloader; for the secondary mode, the system boots from a backup source, activating the flash writer component to download the initial software to flash memory.

\medskip
\clabel[SWFlowBootSystemInitialization]{System Initialization}
\picw=14cm \cinspic img/05-sw-flow-device-booting.png
\caption/f Diagram illustrating the complete system initialization process, detailing the sequence of boot image loading, verification, and core reset for R5 startup.
\medskip

{\it Note:} The DMSC ROM configures a 3-minute watchdog timer ({MCU_RTI0}) timeout. The MCU boot must complete within this period; otherwise, a watchdog timer reset occurs. Once the R5 image (SBL) is loaded, the DMSC ROM restarts the watchdog timer for an additional 3 minutes upon entering the R5 SBL. The customer-provided MCU image must load and install the TI-provided SYSFW image into the DMSC, which manages the watchdog timer during runtime.~\cite[fcLWZx8KgBoQyWDm]

\seccc The DMSC initialization

The DMSC serves as the boot controller for the Public ROM, managing essential configurations such as firewalls, clocks, PLLs, and inter-core communication modes.\fnote{The device supports two primary inter-core topologies: Proxy and Ring.} As shown in Figure \ref[SWFlowBootDeviceDMSCInit], the DMSC releases the reset for R5 CPU0.\fnote{R5FSS_0-0} Its configuration depends on the specified boot mode, with host boot mode imposing different requirements compared to memory boot mode.

\medskip
\clabel[SWFlowBootDeviceDMSCInit]{DMSC Initialization Configuration}
\picw=6cm \cinspic img/05-sw-flow-device-booting-DMCS-init.png
\caption/f Diagram detailing the DMSC initialization process, a critical subset of system initialization, highlighting configurations for boot mode, peripherals, and R5 CPU0 reset, as part of the overall boot sequence in Figure \ref[SWFlowBootSystemInitialization].
\medskip

\label[BootloaderFunctionDescription]
\secc Bootloader Function Description

The bootloader is a critical component of the system. Its primary tasks are:

\begitems
* Loading software into the RAM of individual cores and verifying the authenticity of each core’s image using an X.509 certificate.
* Performing basic system configuration required for the subsequent program execution, such as setting up PLLs, firewall rules, communication topology, and other parameters. These configurations are similar to those managed by the DMSC controller, as illustrated in the Figure \ref[SWFlowBootDeviceDMSCInit]. Additionally, the bootloader must establish an isolation layer to enable the M4 core to operate in isolated mode. The precise clock and PLL configuration is later finalized by the M4 core upon its startup.
\enditems

The bootloader always runs on the real-time core {\it R5_0-0}. It is activated after the DMSC transfers control to it. The bootloader configures essential system resources and then reads information stored in flash memory. Based on this information, it loads either the original or new software into the RAM of all processors, verifying its authenticity using an X.509 certificate. If all images are valid, the system reboots and initiates standard operation. If the original software fails, the bootloader restarts and attempts to boot again. If authentication of new images fails, the system saves an error code to the failure info variable in the boot info structure in the flash, and the system transitions to a process defined within the software update sequence, as described in chapter \ref[SoftwareUpdate].

\medskip
\clabel[SWFlowBootloader]{Bootloader Flow}
\picw=14cm \cinspic img/05-sw-flow-bootloader.png
\caption/f The diagram illustrates the bootloader process.
\medskip

\secc Flash Memory

Flash memory is used to store software for individual cores and information that must be retained in the device even after a power outage. It consists of four main components:

\begitems
* {\sbf Bootloader Image}: Contains the software for running the bootloader. The image comprises an X.509 certificate and a compiled binary code file, as illustrated in Figure \ref[BootImageFormat].
* {\sbf Device Info}: Stores static information such as the serial number, MAC address, certificates, and other device-specific data.
* {\sbf Boot Info}: A simple structure containing three values: {\it failure count}, {\it failure info}, and the addresses of the original and new software. Access to this memory section must always use atomic operations to ensure error-free updates, particularly during software updates. The {\it failure count} indicates whether the new software launched successfully and {\it failure info} variable contains the error code, with further details provided in the firmware update section \ref[SoftwareUpdate].
* {\sbf Original Software}: A memory region for the functional, already in use software for all cores.
* {\sbf New Software}: A memory region for new, unverified software for all cores.
\enditems

\medskip
\clabel[SWFlashStructure]{Flash memory map}
\picw=14cm \cinspic img/05-sw-flash-structure.png
\caption/f The illustration of flash memory map structure
\medskip

The Bootloader Image and Device Info sections are written only once during the initial software loading via the {\sbf flash writer} component. Afterward, these flash memory regions are locked, allowing read-only access and preventing overwrites.


\label[Flash writer Description]
\secc Flash writer description

The {\sbf flash writer} is a specialized component integral to the software update process, yet designed to operate independently as it is also used during the initial software loading of the device. The term {\it flash writer} refers to a standalone module responsible for the first-time provisioning of the device. When the device attempts to load data from flash memory and finds it empty—typically during factory settings, as no data has been written yet—it activates the secondary (backup) boot mode, where the flash writer plays a critical role. The primary objectives of the flash writer are:

\begitems
* To receive software images and store them at designated locations in flash memory.
* To create the flash memory structure and configure write protection for static sections.
\enditems

The flash writer is employed in host-based boot modes. The AM243x processor supports booting from various external sources, but for this work, two are relevant: UART and Ethernet. {\sbf UART} is used in the prototype development phase, while {\sbf Ethernet} is intended for the final device.

The Public ROM code provides the {\sbf BOOTP/TFTP protocol} for Ethernet-based booting. The device supports both Ethernet interfaces RMII and RGMII based on the hardware configuration. For UART-based booting, the {\sbf XMODEM protocol} is utilized.

\seccc The Ethernet Booting Process Description

After device configuration, the bootloader performs a standard BOOTP/TFTP boot. The device sends a BOOTP request with its MAC address to a host TFTP server to be assigned an IP from a pool of addresses. The timeout for each BOOTP packet is 4 seconds, and the ROM will attempt 10 BOOTP retries, after which the boot mode will fail. If the connection is established, the device initiates a TFTP download and is able to receive image data encapsulated in Ethernet packets.\fnote{Device supporting only IPv4 packets.} There is a timeout of 1 second to receive a response for the READ request, and the ROM will retry the READ request 10 times, after which the boot mode will fail. If the TFTP download is successful, data received is stripped of its network headers and the boot data is stored in internal RAM. When the transfer completes and the image is found to have good integrity, the ROM Code will branch to the address defined in the Boot Info field of the boot header.~\cite[fcLWZx8KgBoQyWDm]

There are a few limitations as received packets cannot be IP fragmented or only DIX Ethernet headers are supported.\fnote{Device not support 802.3 with SNAP/LLC, DIX Ethernet with VLAN, and 802.3 with VLAN and SNAP/LLC.} But they don't limit my project in any way.

\seccc The UART Booting Process Description

The ROM Code is always configured on the UART with a transmission speed of 115200 kbaud in 8-n-1 mode.\fnote{This mode means 8 data bits, no parity, and 1 stop bit.~\cite[xncDia3v5VnFFl3k]}

After the ROM code configures the UART interface, the device transmits ASCII capital 'C' characters as pings for several seconds, detectable by the host. An example of the XMODEM protocol in half-duplex transfer is shown in Figure \ref[SWXMODEMExample]. The UART boot mode exclusively supports the CRC mode of the XMODEM protocol, with no support for CHECKSUM mode, and accommodates block sizes of 128 or 1024 bytes. The host must initiate the transfer of the boot image using the XMODEM protocol before the device’s pings cease.~\cite[fcLWZx8KgBoQyWDm]


\medskip
\clabel[SWXMODEMFrame]{UART XMODEM Frame}
\picw=14cm \cinspic img/05-sw-XMODEM-frame.png
\caption/f The format of XMODEM 1024-byte and 128-byte long frame.
\medskip

The Figure \ref[SWXMODEMFrame] illustrates the XMODEM frame format. The meaning of each field is as follows:

\midinsert \clabel[SWXMODEMFrameFields]{XMODEM Frame Fields Description}
\ctable{lll}{
{\sbf Field} & {\sbf Value} & {\sbf Description} \crl
STX & 0x02 & The start character for 1024-byte CRC data blocks. \cr
\cr
SOH & 0x01 & The start character for 128-byte CRC data block. \cr
 \cr
&  & The block number. The first block has \cr
Block Num & 0x01-0xFF & value 1, and the block number\cr
& & wraps around 0xFF to 0. \cr
\cr
Inv Block & 0xFE-0x00 & The inverse block number \cr
Num &  & (bit inverse of the block number). \cr
 \cr
CRC & Based on data & The 16-bit CRC generated from the polynomial \cr
 & &  0x1021. \cr
\cr
}
\caption/t The table describes fields in the XMODEM frame format illustrated in the Figure \ref[SWXMODEMFrame].
\endinsert

\medskip
\clabel[SWXMODEMExample]{Example of XMODE protocol communication}
\picw=7cm \cinspic img/05-sw-XMODEM-sequention.png
\caption/f The example of XMODEM Transfer Protocol in half-duplex mode.
\medskip


\seccc Flash Writer Process

The flash writer sequentially receives and stores data in flash memory according to the flash layout illustrated in Figure \ref[SWFlashStructure]. The process begins by storing the bootloader image for the {\it R5_0-0} core at address {\it 0x00000000}. Next, it creates the device info structure, populating it with received data, and generates an initial boot info structure, which may be empty.

\medskip
\clabel[SWFlashWriter]{Flash Writer sequence diagram}
\picw=14cm \cinspic img/05-sw-flow-flashwriter.png
\caption/f The diagram illustrates the flash write sequence.
\medskip

The flash writer then locks the flash memory regions containing the bootloader image and device info to prevent future overwrites, ensuring these sections remain immutable. Subsequently, it stores the incoming images for each CPU core in the original software section of the flash memory. The boot info structure is updated to specify the address of the original software, with the new software address left undefined and the {\it failure count} and {\it failure info} set to 0. Finally, the flash writer illuminates an LED to indicate the successful completion of the software download process.


\label[SoftwareUpdate]
\sec Firmware Update Process

The firmware update component operates during the standard runtime of the program on the primary real-time core, {\it R5_0-0}. Its primary objective, as implied by its name, is to facilitate the migration of the system to a new software version. Given the need to update secure software, this process is non-trivial and requires careful design to prevent undefined states or unrecoverable errors.


The software update process is structured as follows: The update is initiated when the web interface receives a POST request. First, the {\it failure count} variable in the flash memory’s boot info structure is set to 1 using an atomic operation. The {\it failure count} serves as a counter for attempts to launch the new software, with its role in determining the software version to boot detailed in the bootloader section \ref[BootloaderFunctionDescription]. A {\it failure count} of 0 indicates that the original software is valid, while a non-zero value signifies an ongoing attempt to boot the new software. The maximum number of attempts is configurable, set to 4 in our case, allowing three retries. Incoming data is then received and stored at the {\it new software} address in flash memory, as defined in the flash memory layout Figure \ref[SWFlashStructure].

After storing the data, the device restarts, and the bootloader detects the non-zero {\it failure count}, prompting it to attempt booting the new image. The system then enters standard operation to verify whether the device functions correctly. Two outcomes are possible:

\begitems
* {\sbf Failure}: The {\it failure count} is incremented by 1, and the device restarts. If the {\it failure count} reaches the maximum limit (e.g., 4), the boot info structure is updated to reset {\it failure count} to 0, ensuring the original software is booted on the next attempt. An error code corresponding to the failure is recorded in the {\it failure info} field, with all states detailed in Table \ref[SWFlashFailureInfo].
* {\sbf Success}: The boot info structure is updated to set {\it failure count} to 0, and the addresses of {\it original software} and {\it new software} are swapped, marking the update as successful.
\enditems

\midinsert \clabel[SWFlashFailureInfo]{Interpretation of Failure Info Memory Block}
\ctable{ll}{
{\sbf Value} & {\sbf Description} \crl
0x00 & No error code. \cr
0x01 & Software update failed, the system uses the original version. \cr
0x02 & Software update failed, the new software has not valid certificate. \cr
}
\caption/t The table describes codes in the Failure Info Memory Block in the flash at the position defined by \ref[SWFlashStructure].
\endinsert

\medskip
\clabel[SWSoftwareUpdate]{Software Update Process Diagram}
\picw=14cm \cinspic img/05-sw-flow-fimware-update.png
\caption/f Diagram illustrating the firmware update process.
\medskip


\seccc Ensuring Robustness in Firmware Updates

A key challenge is verifying that the software update completed successfully and preventing failures that could render the system inoperable. The potential issues and their mitigations are as follows:

\begitems
* {\sbf Corrupted or Malicious Software}: If invalid software is uploaded (e.g., due to an attack or process error), the bootloader’s X.509 certificate validation during RAM loading detects the issue, logging error code {\it 0x02} in the {\it failure info} field of the boot info structure.
* {\sbf Damaged Data}: Corrupted data is similarly addressed through certificate-based integrity checks, ensuring the software image’s validity.~\cite[fcLWZx8KgBoQyWDm]
* {\sbf Restart During Update}: If the device restarts (intentionally, unintentionally, or due to a power outage) during the update:
    \begitems
    * {\sbf Incomplete Software Upload}: Certificate validation prevents partial uploads from being executed.
    * {\sbf Interruption During Runtime Validation}: The system increments the {\it failure count} and retries, as the bootloader uses the {\it failure count} to boot the new software upon restart.
    * {\sbf Restart Before Boot Info Update}: The device uploading the firmware receives a negative acknowledgment, indicating an incomplete download. Once the boot info is updated, the internal mechanism handles such errors autonomously.
    \enditems
* {\sbf Residual Old Code in a Core}: This scenario is impossible, as the device restart clears all CPU RAM contents, and the bootloader reloads the new software into RAM from flash memory.
\enditems

To ensure these guarantees, the boot info structure’s integrity must be maintained. This is achieved by using atomic operations for all modifications, ensuring data is never partially altered. A modified {\sbf bitwise memcpy} leveraging the Compare-and-Swap (CASA) instruction\fnote{Compare and Save} prevents interruptions, even by interrupts, guaranteeing complete and consistent updates.~\cite[1sBbZOKXLScuI4se]



\label[SafetyShutdownChap]
\sec Safety shutdown

\label[StandardOperationChap]
\sec Stadard operation


\sec Safe software

\sec Realtime software

\sec Component communication

\medskip
\clabel[SWArchitecture]{Software Architecture}
\picw=14cm \cinspic img/05-sw-architecture.png
\caption/f Software Architecture
\medskip



\medskip
\clabel[SWFlowRunningParallel]{Software Flow Running Parallel}
\picw=14cm \cinspic img/05-sw-flow-running-parallel.png
\caption/f Software Flow Running Parallel
\medskip



\medskip
\clabel[SWFlowRunningSequential]{Software Flow Running Sequential}
\picw=14cm \cinspic img/05-sw-flow-running-sequential.png
\caption/f Software Flow Running Sequential
\medskip